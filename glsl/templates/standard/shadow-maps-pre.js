module.exports = function( obj ){
var __t,__p='';
__p+='\n\n#define SHADOW_COUNT '+
(obj.shadowCount)+
'\n\n#if __VERSION__ == 300\n  precision lowp sampler2DShadow;\n\n  #define DepthSampler sampler2DShadow\n  \n#else\n  #define DepthSampler sampler2D\n#endif\n\n\n';
 for(var i = 0; i<obj.shadowCount; i++){ 
__p+='\n  uniform DepthSampler tShadowMap'+
(i)+
';\n';
 } 
__p+='\n\n\n\n\nuniform highp vec2 uShadowKernelRotation;\nuniform highp mat4 uShadowMatrices[SHADOW_COUNT];\nuniform highp vec4 uShadowTexelBiasVector[SHADOW_COUNT];\nuniform       vec2 uShadowMapSize[SHADOW_COUNT];\n\n\nstruct ShadowMapData {\n  mat4 projection;\n  vec4 texelBiasVector;\n  vec2 size; // size , 1/size\n};\n\n#define GET_SHADOWMAP_DATA(i) ShadowMapData( uShadowMatrices[i], uShadowTexelBiasVector[i], uShadowMapSize[i])\n\n\n// RGB depth decoding\n// ------------------\nhighp float decodeDepthRGB(highp vec3 rgb){\n  return(rgb.x+rgb.y*(1.0/255.0))+rgb.z*(1.0/65025.0);\n}\n\n\n#if __VERSION__ == 300\n  \n      \n  float textureShadow( DepthSampler t, float ref, vec2 uvs ){\n    return texture(t, vec3( uvs, ref ) );\n  }\n\n  vec2 textureShadow( DepthSampler t, float ref, vec4 uvs ){\n    \n    return vec2(\n      texture(t, vec3( uvs.xy, ref ) ),\n      texture(t, vec3( uvs.zw, ref ) )\n    );\n\n  }\n\n  vec4 textureShadow( DepthSampler t, float ref, vec4 uvs0, vec4 uvs1 ){\n    \n    return vec4(\n      texture(t, vec3( uvs0.xy, ref ) ),\n      texture(t, vec3( uvs0.zw, ref ) ),\n      texture(t, vec3( uvs1.xy, ref ) ),\n      texture(t, vec3( uvs1.zw, ref ) )\n    );\n\n  }\n\n\n\n#else\n\n\n\n  #if depthFormat( D_RGB )\n    float FETCH_DEPTH( DepthSampler t, vec2 uvs ){\n      return decodeDepthRGB( texture2D(t,uvs).xyz );\n    }\n    //define FETCH_DEPTH(t,uvs) decodeDepthRGB( texture2D(t,uvs).xyz )\n  #endif\n\n  #if depthFormat( D_DEPTH )\n    float FETCH_DEPTH( DepthSampler t, vec2 uvs ){\n      return texture2D(t,uvs).x;\n    }\n    //define FETCH_DEPTH(t,uvs) texture2D(t,uvs).x\n  #endif\n\n  \n  float textureShadow( DepthSampler t, float ref, vec2 uvs ){\n    return step( ref, FETCH_DEPTH(t,uvs));\n  }\n\n  vec2 textureShadow( DepthSampler t, float ref, vec4 uvs ){\n    \n    vec2 occl = vec2(\n      FETCH_DEPTH(t,uvs.xy),\n      FETCH_DEPTH(t,uvs.zw)\n    );\n\n    return step( vec2(ref), occl );\n  }\n\n  vec4 textureShadow( DepthSampler t, float ref, vec4 uvs0, vec4 uvs1 ){\n    \n    vec4 occl = vec4(\n      FETCH_DEPTH(t,uvs0.xy),\n      FETCH_DEPTH(t,uvs0.zw),\n      FETCH_DEPTH(t,uvs1.xy),\n      FETCH_DEPTH(t,uvs1.zw)\n    );\n\n    return step( vec4(ref), occl );\n  }\n\n#endif\n\n\n\n\n\n\n\nfloat resolveShadowNoFiltering(highp float fragZ, DepthSampler depth,highp vec2 uv ){\n    return textureShadow( depth, fragZ, uv );\n}\n\n\n#if __VERSION__ == 300\n  // Bilinear is natively supported in ES3\n  // Shadowmap filtering must be set by sampler2DShadow filter parameter\n\n  float resolveShadow2x1(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n    return textureShadow( depth, fragZ, uv );\n  }\n\n  float resolveShadow2x2(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n    return textureShadow( depth, fragZ, uv );\n  }\n\n#else\n\n  float resolveShadow2x1(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n\n    highp float coordsPx = uv.x*mapSize.x;\n    highp float uvMin = floor( coordsPx ) * mapSize.y;\n    highp float uvMax = ceil(  coordsPx ) * mapSize.y;\n\n    vec2 occl = textureShadow( depth, fragZ, vec4(\n      uvMin,uv.y,\n      uvMax,uv.y\n    ));\n\n    highp float ratio = coordsPx - uvMin*mapSize.x;\n    return ( ratio * occl.y + occl.x ) - ratio * occl.x;\n\n  }\n\n  float resolveShadow2x2(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\n\n    highp vec2 coordsPx = uv*mapSize.x;\n    highp vec2 uvMin=floor( coordsPx ) *mapSize.y;\n    highp vec2 uvMax=ceil(  coordsPx ) *mapSize.y;\n\n    vec4 occl = textureShadow( depth, fragZ, \n      vec4(\n        uvMin,\n        vec2(uvMax.x,uvMin.y)\n      ),\n      vec4(\n        vec2(uvMin.x,uvMax.y),\n        uvMax\n      )\n    );\n\n    highp vec2 ratio = coordsPx - uvMin*mapSize.x;\n    vec2  t = ( ratio.y * occl.zw + occl.xy ) - ratio.y * occl.xy;\n\n    return(ratio.x*t.y+t.x)-ratio.x*t.x;\n  }\n\n#endif\n\n\nfloat calcLightOcclusions(DepthSampler depth, highp vec3 fragCoord, vec2 mapSize ){\n  float s;\n\n  highp vec2 kernelOffset = uShadowKernelRotation * mapSize.y;\n\n  // NO FILTER\n  #if shadowFilter( PCFNONE )\n\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy );\n  #endif\n\n  // PCF4x1\n  #if shadowFilter( PCF4x1 )\n\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + kernelOffset                    );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy - kernelOffset                    );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x)  );\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x)  );\n    s /= 4.0;\n  #endif\n\n  // PCF4x4\n  #if shadowFilter( PCF4x4 )\n\n    s = resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + kernelOffset                         , mapSize );\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy - kernelOffset                         , mapSize );\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x) , mapSize );\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x) , mapSize );\n    s /= 4.0;\n  #endif\n\n  // PCF2x2\n  #if shadowFilter( PCF2x2 )\n\n    s = resolveShadow2x1( fragCoord.z, depth, fragCoord.xy + kernelOffset , mapSize);\n    s+= resolveShadow2x1( fragCoord.z, depth, fragCoord.xy - kernelOffset , mapSize);\n    s /= 2.0;\n  #endif\n\n\n  if( any( greaterThan( abs( fragCoord - vec3(.5) ), vec3(.5) ) ) ){\n    s = 1.0;\n  }\n\n  return s;\n\n}\n\n// float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)\n// {\n//     float invNdotL = 1.0 - saturate(dot(lightDirection, normalWS));\n//     float scale = invNdotL * _ShadowBias.y;\n\n//     // normal bias is negative since we want to apply an inset normal offset\n//     positionWS = lightDirection * _ShadowBias.xxx + positionWS;\n//     positionWS = normalWS * scale.xxx + positionWS;\n//     return positionWS;\n// }\n\nvec3 calcShadowPosition( vec4 texelBiasVector, mat4 shadowProjection, vec3 worldPos, vec3 worldNormal, float invMapSize )\n{\n  float WoP = dot( texelBiasVector, vec4( worldPos, 1.0 ) );\n\n  WoP *= .0005+2.0*invMapSize;\n\n  highp vec4 fragCoord = shadowProjection * vec4( worldPos + WoP * worldNormal, 1.0);\n  return fragCoord.xyz / fragCoord.w;\n}\n\n\n\nvec3 calcShadowPosition( ShadowMapData shadowmap, vec3 worldPos, vec3 worldNormal )\n{\n  float WoP = dot( shadowmap.texelBiasVector, vec4( worldPos, 1.0 ) );\n\n  WoP *= .005+2.0*shadowmap.size.y;\n\n  highp vec4 fragCoord = shadowmap.projection * vec4( worldPos + WoP * worldNormal, 1.0);\n  return fragCoord.xyz / fragCoord.w;\n}\n\n\nmediump float SampleShadowAttenuation( ShadowMapData shadowmap, DepthSampler texture, vec3 worldPos, vec3 worldNormal  ) {\n  highp vec3 coords = calcShadowPosition( shadowmap, worldPos, worldNormal );\n  return calcLightOcclusions( texture, coords, shadowmap.size );\n}';
return __p;
}