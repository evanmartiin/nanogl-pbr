module.exports = function( obj ){
var __t,__p='';
__p+='\r\n\r\n#define SHADOW_COUNT '+
(obj.shadowCount)+
'\r\n\r\n#if __VERSION__ == 300\r\n  precision lowp sampler2DShadow;\r\n\r\n  #define DepthSampler sampler2DShadow\r\n  \r\n#else\r\n  #define DepthSampler sampler2D\r\n#endif\r\n\r\n\r\n';
 for(var i = 0; i<obj.shadowCount; i++){ 
__p+='\r\n  uniform DepthSampler tShadowMap'+
(i)+
';\r\n';
 } 
__p+='\r\n\r\n\r\n\r\n\r\nuniform highp vec2 uShadowKernelRotation;\r\nuniform highp mat4 uShadowMatrices[SHADOW_COUNT];\r\nuniform highp vec4 uShadowTexelBiasVector[SHADOW_COUNT];\r\nuniform       vec2 uShadowMapSize[SHADOW_COUNT];\r\n\r\n\r\nstruct ShadowMapData {\r\n  mat4 projection;\r\n  vec4 texelBiasVector;\r\n  vec2 size; // size , 1/size\r\n};\r\n\r\n#define GET_SHADOWMAP_DATA(i) ShadowMapData( uShadowMatrices[i], uShadowTexelBiasVector[i], uShadowMapSize[i])\r\n\r\n\r\n// RGB depth decoding\r\n// ------------------\r\nhighp float decodeDepthRGB(highp vec3 rgb){\r\n  return(rgb.x+rgb.y*(1.0/255.0))+rgb.z*(1.0/65025.0);\r\n}\r\n\r\n\r\n#if __VERSION__ == 300\r\n  \r\n      \r\n  float textureShadow( DepthSampler t, float ref, vec2 uvs ){\r\n    return texture(t, vec3( uvs, ref ) );\r\n  }\r\n\r\n  vec2 textureShadow( DepthSampler t, float ref, vec4 uvs ){\r\n    \r\n    return vec2(\r\n      texture(t, vec3( uvs.xy, ref ) ),\r\n      texture(t, vec3( uvs.zw, ref ) )\r\n    );\r\n\r\n  }\r\n\r\n  vec4 textureShadow( DepthSampler t, float ref, vec4 uvs0, vec4 uvs1 ){\r\n    \r\n    return vec4(\r\n      texture(t, vec3( uvs0.xy, ref ) ),\r\n      texture(t, vec3( uvs0.zw, ref ) ),\r\n      texture(t, vec3( uvs1.xy, ref ) ),\r\n      texture(t, vec3( uvs1.zw, ref ) )\r\n    );\r\n\r\n  }\r\n\r\n\r\n\r\n#else\r\n\r\n\r\n\r\n  #if depthFormat( D_RGB )\r\n    float FETCH_DEPTH( DepthSampler t, vec2 uvs ){\r\n      return decodeDepthRGB( texture2D(t,uvs).xyz );\r\n    }\r\n    //define FETCH_DEPTH(t,uvs) decodeDepthRGB( texture2D(t,uvs).xyz )\r\n  #endif\r\n\r\n  #if depthFormat( D_DEPTH )\r\n    float FETCH_DEPTH( DepthSampler t, vec2 uvs ){\r\n      return texture2D(t,uvs).x;\r\n    }\r\n    //define FETCH_DEPTH(t,uvs) texture2D(t,uvs).x\r\n  #endif\r\n\r\n  \r\n  float textureShadow( DepthSampler t, float ref, vec2 uvs ){\r\n    return step( ref, FETCH_DEPTH(t,uvs));\r\n  }\r\n\r\n  vec2 textureShadow( DepthSampler t, float ref, vec4 uvs ){\r\n    \r\n    vec2 occl = vec2(\r\n      FETCH_DEPTH(t,uvs.xy),\r\n      FETCH_DEPTH(t,uvs.zw)\r\n    );\r\n\r\n    return step( vec2(ref), occl );\r\n  }\r\n\r\n  vec4 textureShadow( DepthSampler t, float ref, vec4 uvs0, vec4 uvs1 ){\r\n    \r\n    vec4 occl = vec4(\r\n      FETCH_DEPTH(t,uvs0.xy),\r\n      FETCH_DEPTH(t,uvs0.zw),\r\n      FETCH_DEPTH(t,uvs1.xy),\r\n      FETCH_DEPTH(t,uvs1.zw)\r\n    );\r\n\r\n    return step( vec4(ref), occl );\r\n  }\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfloat resolveShadowNoFiltering(highp float fragZ, DepthSampler depth,highp vec2 uv ){\r\n    return textureShadow( depth, fragZ, uv );\r\n}\r\n\r\n\r\n#if __VERSION__ == 300\r\n  // Bilinear is natively supported in ES3\r\n  // Shadowmap filtering must be set by sampler2DShadow filter parameter\r\n\r\n  float resolveShadow2x1(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\r\n    return textureShadow( depth, fragZ, uv );\r\n  }\r\n\r\n  float resolveShadow2x2(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\r\n    return textureShadow( depth, fragZ, uv );\r\n  }\r\n\r\n#else\r\n\r\n  float resolveShadow2x1(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\r\n\r\n    highp float coordsPx = uv.x*mapSize.x;\r\n    highp float uvMin = floor( coordsPx ) * mapSize.y;\r\n    highp float uvMax = ceil(  coordsPx ) * mapSize.y;\r\n\r\n    vec2 occl = textureShadow( depth, fragZ, vec4(\r\n      uvMin,uv.y,\r\n      uvMax,uv.y\r\n    ));\r\n\r\n    highp float ratio = coordsPx - uvMin*mapSize.x;\r\n    return ( ratio * occl.y + occl.x ) - ratio * occl.x;\r\n\r\n  }\r\n\r\n  float resolveShadow2x2(highp float fragZ, DepthSampler depth,highp vec2 uv, vec2 mapSize ){\r\n\r\n    highp vec2 coordsPx = uv*mapSize.x;\r\n    highp vec2 uvMin=floor( coordsPx ) *mapSize.y;\r\n    highp vec2 uvMax=ceil(  coordsPx ) *mapSize.y;\r\n\r\n    vec4 occl = textureShadow( depth, fragZ, \r\n      vec4(\r\n        uvMin,\r\n        vec2(uvMax.x,uvMin.y)\r\n      ),\r\n      vec4(\r\n        vec2(uvMin.x,uvMax.y),\r\n        uvMax\r\n      )\r\n    );\r\n\r\n    highp vec2 ratio = coordsPx - uvMin*mapSize.x;\r\n    vec2  t = ( ratio.y * occl.zw + occl.xy ) - ratio.y * occl.xy;\r\n\r\n    return(ratio.x*t.y+t.x)-ratio.x*t.x;\r\n  }\r\n\r\n#endif\r\n\r\n\r\nfloat calcLightOcclusions(DepthSampler depth, highp vec3 fragCoord, vec2 mapSize ){\r\n  float s;\r\n\r\n  highp vec2 kernelOffset = uShadowKernelRotation * mapSize.y;\r\n\r\n  // NO FILTER\r\n  #if shadowFilter( PCFNONE )\r\n\r\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy );\r\n  #endif\r\n\r\n  // PCF4x1\r\n  #if shadowFilter( PCF4x1 )\r\n\r\n    s = resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + kernelOffset                    );\r\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy - kernelOffset                    );\r\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x)  );\r\n    s+= resolveShadowNoFiltering( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x)  );\r\n    s /= 4.0;\r\n  #endif\r\n\r\n  // PCF4x4\r\n  #if shadowFilter( PCF4x4 )\r\n\r\n    s = resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + kernelOffset                         , mapSize );\r\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy - kernelOffset                         , mapSize );\r\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(-kernelOffset.y,kernelOffset.x) , mapSize );\r\n    s+= resolveShadow2x2( fragCoord.z, depth, fragCoord.xy + vec2(kernelOffset.y,-kernelOffset.x) , mapSize );\r\n    s /= 4.0;\r\n  #endif\r\n\r\n  // PCF2x2\r\n  #if shadowFilter( PCF2x2 )\r\n\r\n    s = resolveShadow2x1( fragCoord.z, depth, fragCoord.xy + kernelOffset , mapSize);\r\n    s+= resolveShadow2x1( fragCoord.z, depth, fragCoord.xy - kernelOffset , mapSize);\r\n    s /= 2.0;\r\n  #endif\r\n\r\n\r\n  if( any( greaterThan( abs( fragCoord - vec3(.5) ), vec3(.5) ) ) ){\r\n    s = 1.0;\r\n  }\r\n\r\n  return s;\r\n\r\n}\r\n\r\n// float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)\r\n// {\r\n//     float invNdotL = 1.0 - saturate(dot(lightDirection, normalWS));\r\n//     float scale = invNdotL * _ShadowBias.y;\r\n\r\n//     // normal bias is negative since we want to apply an inset normal offset\r\n//     positionWS = lightDirection * _ShadowBias.xxx + positionWS;\r\n//     positionWS = normalWS * scale.xxx + positionWS;\r\n//     return positionWS;\r\n// }\r\n\r\nvec3 calcShadowPosition( vec4 texelBiasVector, mat4 shadowProjection, vec3 worldPos, vec3 worldNormal, float invMapSize )\r\n{\r\n  float WoP = dot( texelBiasVector, vec4( worldPos, 1.0 ) );\r\n\r\n  WoP *= .0005+2.0*invMapSize;\r\n\r\n  highp vec4 fragCoord = shadowProjection * vec4( worldPos + WoP * worldNormal, 1.0);\r\n  return fragCoord.xyz / fragCoord.w;\r\n}\r\n\r\n\r\n\r\nvec3 calcShadowPosition( ShadowMapData shadowmap, vec3 worldPos, vec3 worldNormal )\r\n{\r\n  float WoP = dot( shadowmap.texelBiasVector, vec4( worldPos, 1.0 ) );\r\n\r\n  WoP *= .005+2.0*shadowmap.size.y;\r\n\r\n  highp vec4 fragCoord = shadowmap.projection * vec4( worldPos + WoP * worldNormal, 1.0);\r\n  return fragCoord.xyz / fragCoord.w;\r\n}\r\n\r\n\r\nmediump float SampleShadowAttenuation( ShadowMapData shadowmap, DepthSampler texture, vec3 worldPos, vec3 worldNormal  ) {\r\n  highp vec3 coords = calcShadowPosition( shadowmap, worldPos, worldNormal );\r\n  return calcLightOcclusions( texture, coords, shadowmap.size );\r\n}';
return __p;
}