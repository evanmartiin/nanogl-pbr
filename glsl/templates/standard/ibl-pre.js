module.exports = function( obj ){
var __t,__p='';
__p+='#ifndef _H_SPECULAR_IBL_\n#define _H_SPECULAR_IBL_\n\n'+
( require( "../../includes/ibl-rotation.glsl" )() )+
'\n'+
( require( "../../includes/ibl-box-projection.glsl" )() )+
'\n'+
( require( "../../includes/octwrap-decode.glsl" )() )+
'\n'+
( require( "../../includes/decode-rgbe.glsl" )() )+
'\n\n/* =========================================================\n  OCTA\n========================================================= */\n#if iblType( OCTA )\n\n  uniform sampler2D tEnv;\n\n  #define SpecularIBL( skyDir, roughness, wpos ) SampleIBL( skyDir, roughness, wpos )\n\n  const vec2 _IBL_UVM = vec2(\n    0.25*(254.0/256.0),\n    0.125*0.5*(254.0/256.0)\n  );\n\n  vec3 SampleIBL( vec3 skyDir, float roughness, vec3 worldPos)\n  {\n    skyDir = IblBoxProjection(skyDir, worldPos);\n    skyDir = IblRotateDir(skyDir);\n    vec2 uvA = octwrapDecode( skyDir );\n\n    float r7   = 7.0*roughness;\n    float frac = fract(r7);\n\n    uvA = uvA * _IBL_UVM + vec2(\n      0.5,\n      0.125*0.5 + 0.125 * ( r7 - frac )\n    );\n\n    #if glossNearest\n\n      return decodeRGBE( texture2D(tEnv,uvA) );\n\n    #else\n\n      vec2 uvB=uvA+vec2(0.0,0.125);\n      return  mix(\n        decodeRGBE( texture2D(tEnv,uvA) ),\n        decodeRGBE( texture2D(tEnv,uvB) ),\n        frac\n      );\n\n    #endif\n\n  }\n\n\n/* =========================================================\n  PMREM\n========================================================= */\n#elif iblType( PMREM ) && __VERSION__ == 300\n\n  uniform samplerCube tEnv;\n\n  #define SpecularIBL( skyDir, roughness, wpos ) SampleIBLPMRem( skyDir, roughness, wpos )\n\n\n  const float MaxRangeRGBD = 255.0; \n\n  vec3 decodeRGBD(vec4 rgbd)\n  {\n    float a = max(rgbd.a, 0.0);\n    return rgbd.rgb * ((MaxRangeRGBD / 255.0) / a);\n  }\n\n  vec3 SampleIBLPMRem( vec3 skyDir, float roughness, wpos)\n  {\n    skyDir = IblBoxProjection(skyDir, worldPos);\n    skyDir = IblRotateDir(skyDir);\n    float r7   = 7.0*roughness;\n\n    float mipA = floor(r7);\n    float mipB = ceil(r7);\n    float delta = r7 - mipA;\n\n    #if glossNearest\n\n      return decodeRGBD( textureLod(tEnv,skyDir, mipA) );\n\n    #else\n\n      vec3 color = mix(\n        decodeRGBD( textureLod(tEnv, skyDir, mipA) ),\n        decodeRGBD( textureLod(tEnv, skyDir, mipB) ),\n        delta\n      );\n\n      return color;\n\n    #endif\n\n  }\n\n\n#endif\n\n\n\n\n\nvec3 ComputeIBLDiffuse( vec3 worldNormal ){\n  // TODO: the model should set this varying in vertex shader\n  #if perVertexIrrad\n    return vIrradiance;\n  #else\n    return SampleSH(IblRotateDir(worldNormal), uSHCoeffs );\n  #endif\n}\n\n#endif';
return __p;
}